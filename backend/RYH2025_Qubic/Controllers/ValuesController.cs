using Microsoft.AspNetCore.Mvc;
using QubicContractAnalyzer.Services;
using RYH2025_Qubic.Persistence;

namespace RYH2025_Qubic.Controllers;

[Route("api/[controller]")]
public class ValuesController : ControllerBase
{
    private IConfiguration _configuration { get; set; }
    private ApplicationDbContext _dbContext { get; set; }
    public ValuesController(IConfiguration configuration,ApplicationDbContext dbContext) {
    _configuration = configuration;
        _dbContext = dbContext;
    }
    // GET api/values
    [HttpGet]
    public async Task<IEnumerable<string>> Get()
    {
        var contractAnalyzer = new QubicContractService(_configuration);
        //QEARN
        //var result = await contractAnalyzer.ProcessContractCompleteAsync("using namespace QPI;\r\n\r\nconstexpr uint64 QEARN_MINIMUM_LOCKING_AMOUNT = 10000000;\r\nconstexpr uint64 QEARN_MAX_LOCKS = 4194304;\r\nconstexpr uint64 QEARN_MAX_EPOCHS = 4096;\r\nconstexpr uint64 QEARN_MAX_USERS = 131072;\r\nconstexpr uint64 QEARN_MAX_LOCK_AMOUNT = 1000000000000ULL;\r\nconstexpr uint64 QEARN_MAX_BONUS_AMOUNT = 1000000000000ULL;\r\nconstexpr uint64 QEARN_INITIAL_EPOCH = 138;\r\n\r\nconstexpr uint64 QEARN_EARLY_UNLOCKING_PERCENT_0_3 = 0;\r\nconstexpr uint64 QEARN_EARLY_UNLOCKING_PERCENT_4_7 = 5;\r\nconstexpr uint64 QEARN_EARLY_UNLOCKING_PERCENT_8_11 = 5;\r\nconstexpr uint64 QEARN_EARLY_UNLOCKING_PERCENT_12_15 = 10;\r\nconstexpr uint64 QEARN_EARLY_UNLOCKING_PERCENT_16_19 = 15;\r\nconstexpr uint64 QEARN_EARLY_UNLOCKING_PERCENT_20_23 = 20;\r\nconstexpr uint64 QEARN_EARLY_UNLOCKING_PERCENT_24_27 = 25;\r\nconstexpr uint64 QEARN_EARLY_UNLOCKING_PERCENT_28_31 = 30;\r\nconstexpr uint64 QEARN_EARLY_UNLOCKING_PERCENT_32_35 = 35;\r\nconstexpr uint64 QEARN_EARLY_UNLOCKING_PERCENT_36_39 = 40;\r\nconstexpr uint64 QEARN_EARLY_UNLOCKING_PERCENT_40_43 = 45;\r\nconstexpr uint64 QEARN_EARLY_UNLOCKING_PERCENT_44_47 = 50;\r\nconstexpr uint64 QEARN_EARLY_UNLOCKING_PERCENT_48_51 = 55;\r\n\r\nconstexpr uint64 QEARN_BURN_PERCENT_0_3 = 0;\r\nconstexpr uint64 QEARN_BURN_PERCENT_4_7 = 45;\r\nconstexpr uint64 QEARN_BURN_PERCENT_8_11 = 45;\r\nconstexpr uint64 QEARN_BURN_PERCENT_12_15 = 45;\r\nconstexpr uint64 QEARN_BURN_PERCENT_16_19 = 40;\r\nconstexpr uint64 QEARN_BURN_PERCENT_20_23 = 40;\r\nconstexpr uint64 QEARN_BURN_PERCENT_24_27 = 35;\r\nconstexpr uint64 QEARN_BURN_PERCENT_28_31 = 35;\r\nconstexpr uint64 QEARN_BURN_PERCENT_32_35 = 35;\r\nconstexpr uint64 QEARN_BURN_PERCENT_36_39 = 30;\r\nconstexpr uint64 QEARN_BURN_PERCENT_40_43 = 30;\r\nconstexpr uint64 QEARN_BURN_PERCENT_44_47 = 30;\r\nconstexpr uint64 QEARN_BURN_PERCENT_48_51 = 25;\r\n\r\nconstexpr sint32 QEARN_INVALID_INPUT_AMOUNT = 0;\r\nconstexpr sint32 QEARN_LOCK_SUCCESS = 1;\r\nconstexpr sint32 QEARN_INVALID_INPUT_LOCKED_EPOCH = 2;\r\nconstexpr sint32 QEARN_INVALID_INPUT_UNLOCK_AMOUNT = 3;\r\nconstexpr sint32 QEARN_EMPTY_LOCKED = 4;\r\nconstexpr sint32 QEARN_UNLOCK_SUCCESS = 5;\r\nconstexpr sint32 QEARN_OVERFLOW_USER = 6;\r\nconstexpr sint32 QEARN_LIMIT_LOCK = 7;\r\n\r\nenum QearnLogInfo {\r\n    QearnSuccessLocking = 0,\r\n    QearnFailedTransfer = 1,\r\n    QearnLimitLocking = 2,\r\n    QearnOverflowUser = 3,\r\n    QearnInvalidInput = 4,\r\n    QearnSuccessEarlyUnlocking = 5,\r\n    QearnSuccessFullyUnlocking = 6,\r\n};\r\nstruct QearnLogger\r\n{\r\n    uint32 _contractIndex;\r\n    id sourcePublicKey;\r\n    id destinationPublicKey;\r\n    sint64 amount;\r\n    uint32 _type;\r\n    char _terminator; \r\n};\r\n\r\nstruct QEARN2\r\n{\r\n};\r\n\r\nstruct QEARN : public ContractBase\r\n{\r\npublic:\r\n    struct getLockInfoPerEpoch_input {\r\n\t\tuint32 Epoch;                             /* epoch number to get information */\r\n    };\r\n\r\n    struct getLockInfoPerEpoch_output {\r\n        uint64 lockedAmount;                      /* initial total locked amount in epoch */\r\n        uint64 bonusAmount;                       /* initial bonus amount in epoch*/\r\n        uint64 currentLockedAmount;               /* total locked amount in epoch. exactly the amount excluding the amount unlocked early*/\r\n        uint64 currentBonusAmount;                /* bonus amount in epoch excluding the early unlocking */\r\n        uint64 yield;                             /* Yield calculated by 10000000 multiple*/\r\n    };\r\n\r\n    struct getUserLockedInfo_input {\r\n        id user;\r\n        uint32 epoch;\r\n    };\r\n\r\n    struct getUserLockedInfo_output {\r\n        uint64 lockedAmount;                   /* the amount user locked at input.epoch */\r\n    };\r\n\r\n    /*\r\n        getStateOfRound FUNCTION\r\n\r\n        getStateOfRound function returns following.\r\n\r\n        0 = open epoch,not started yet\r\n        1 = running epoch\r\n        2 = ended epoch(>52weeks)\r\n    */\r\n    struct getStateOfRound_input {\r\n        uint32 epoch;\r\n    };\r\n\r\n    struct getStateOfRound_output {\r\n        uint32 state;\r\n    };\r\n    \r\n    /*\r\n        getUserLockStatus FUNCTION\r\n\r\n        the status will return the binary status.\r\n        1101010010110101001011010100101101010010110101001001\r\n\r\n        1 means locked in [index of 1] weeks ago. 0 means unlocked in [index of zero] weeks ago.\r\n        The frontend can get the status of locked in 52 epochs. in above binary status, \r\n        the frontend can know that user locked 0 week ago, 1 week ago, 3 weeks ago, 5, 8,10,11,13 weeks ago.\r\n    */\r\n    struct getUserLockStatus_input {\r\n        id user;\r\n    };\r\n\r\n    struct getUserLockStatus_output {\r\n        uint64 status;\r\n    };\r\n\r\n    /*\r\n        getEndedStatus FUNCTION\r\n\r\n        output.earlyRewardedAmount returns the amount rewarded by unlocking early at current epoch\r\n        output.earlyUnlockedAmount returns the amount unlocked by unlocking early at current epoch\r\n        output.fullyRewardedAmount returns the amount rewarded by unlocking fully at the end of previous epoch\r\n        output.fullyUnlockedAmount returns the amount unlocked by unlocking fully at the end of previous epoch\r\n\r\n        let's assume that current epoch is 170, user unlocked the 15B qu totally at this epoch and he got the 30B qu of reward.\r\n        in this case, output.earlyUnlockedAmount = 15B qu, output.earlyRewardedAmount = 30B qu\r\n        if this user unlocks 3B qu additionally at this epoch and rewarded 6B qu, \r\n        in this case, output.earlyUnlockedAmount = 18B qu, output.earlyRewardedAmount = 36B qu\r\n        state.earlyUnlocker array would be initialized at the end of every epoch\r\n\r\n        let's assume also that current epoch is 170, user got the 15B(locked amount for 52 weeks) + 10B(rewarded amount for 52 weeks) at the end of epoch 169.\r\n        in this case, output.fullyRewardedAmount = 10B, output.fullyUnlockedAmount = 15B\r\n        state.fullyUnlocker array would be decided with distributions at the end of every epoch\r\n\r\n        state.earlyUnlocker, state.fullyUnlocker arrays would be initialized and decided by following expression at the END_EPOCH_WITH_LOCALS function.\r\n        state._earlyUnlockedCnt = 0;\r\n        state._fullyUnlockedCnt = 0;\r\n    */\r\n\r\n    struct getEndedStatus_input {\r\n        id user;\r\n    };\r\n\r\n    struct getEndedStatus_output {\r\n        uint64 fullyUnlockedAmount;\r\n        uint64 fullyRewardedAmount;\r\n        uint64 earlyUnlockedAmount;\r\n        uint64 earlyRewardedAmount;\r\n    };\r\n\r\n\tstruct lock_input {\t\r\n    };\r\n\r\n    struct lock_output {\t\r\n        sint32 returnCode;\r\n    };\r\n\r\n    struct unlock_input {\r\n        uint64 amount;                            /* unlocking amount */\t\r\n        uint32 lockedEpoch;                      /* locked epoch */\r\n    };\r\n\r\n    struct unlock_output {\r\n        sint32 returnCode;\r\n    };\r\n\r\n    struct getStatsPerEpoch_input {\r\n        uint32 epoch;\r\n    };\r\n\r\n    struct getStatsPerEpoch_output {\r\n\r\n        uint64 earlyUnlockedAmount;\r\n        uint64 earlyUnlockedPercent;\r\n        uint64 totalLockedAmount;\r\n        uint64 averageAPY;\r\n\r\n    };\r\n\r\n    struct getBurnedAndBoostedStats_input {\r\n        \r\n    };\r\n\r\n    struct getBurnedAndBoostedStats_output {\r\n\r\n        uint64 burnedAmount;\r\n        uint64 averageBurnedPercent;\r\n        uint64 boostedAmount;\r\n        uint64 averageBoostedPercent;\r\n        uint64 rewardedAmount;\r\n        uint64 averageRewardedPercent;\r\n\r\n    };\r\n\r\n    struct getBurnedAndBoostedStatsPerEpoch_input {\r\n        uint32 epoch;\r\n    };\r\n\r\n    struct getBurnedAndBoostedStatsPerEpoch_output {\r\n\r\n        uint64 burnedAmount;\r\n        uint64 burnedPercent;\r\n        uint64 boostedAmount;\r\n        uint64 boostedPercent;\r\n        uint64 rewardedAmount;\r\n        uint64 rewardedPercent;\r\n\r\n    };\r\n\r\nprotected:\r\n\r\n    struct RoundInfo {\r\n\r\n        uint64 _totalLockedAmount;            // The initial total locked amount in any epoch.  Max Epoch is 65535\r\n        uint64 _epochBonusAmount;             // The initial bonus amount per an epoch.         Max Epoch is 65535 \r\n\r\n    };\r\n\r\n    Array<RoundInfo, QEARN_MAX_EPOCHS> _initialRoundInfo;\r\n    Array<RoundInfo, QEARN_MAX_EPOCHS> _currentRoundInfo;\r\n\r\n    struct EpochIndexInfo {\r\n\r\n        uint32 startIndex;\r\n        uint32 endIndex;\r\n    };\r\n\r\n    Array<EpochIndexInfo, QEARN_MAX_EPOCHS> _epochIndex;\r\n\r\n    struct LockInfo {\r\n\r\n        uint64 _lockedAmount;\r\n        id ID;\r\n        uint32 _lockedEpoch;\r\n        \r\n    };\r\n\r\n    Array<LockInfo, QEARN_MAX_LOCKS> locker;\r\n\r\n    struct HistoryInfo {\r\n\r\n        uint64 _unlockedAmount;\r\n        uint64 _rewardedAmount;\r\n        id _unlockedID;\r\n\r\n    };\r\n\r\n    Array<HistoryInfo, QEARN_MAX_USERS> earlyUnlocker;\r\n    Array<HistoryInfo, QEARN_MAX_USERS> fullyUnlocker;\r\n    \r\n    uint32 _earlyUnlockedCnt;\r\n    uint32 _fullyUnlockedCnt;\r\n\r\n    struct StatsInfo {\r\n\r\n        uint64 burnedAmount;\r\n        uint64 boostedAmount;\r\n        uint64 rewardedAmount;\r\n\r\n    };\r\n\r\n    Array<StatsInfo, QEARN_MAX_EPOCHS> statsInfo;\r\n\r\n    struct getStateOfRound_locals {\r\n        uint32 firstEpoch;\r\n    };\r\n\r\n    PUBLIC_FUNCTION_WITH_LOCALS(getStateOfRound)\r\n        if(input.epoch < QEARN_INITIAL_EPOCH) \r\n        {                                                            // non staking\r\n            output.state = 2; \r\n            return ;\r\n        }\r\n        if(input.epoch > qpi.epoch()) \r\n        {\r\n            output.state = 0;                                     // opening round, not started yet\r\n        }\r\n        locals.firstEpoch = qpi.epoch() - 52;\r\n        if(input.epoch <= qpi.epoch() && input.epoch >= locals.firstEpoch) \r\n        {\r\n            output.state = 1;       // running round, available unlocking early\r\n        }\r\n        if(input.epoch < locals.firstEpoch) \r\n        {\r\n            output.state = 2;       // ended round\r\n        }\r\n    _\r\n\r\n    PUBLIC_FUNCTION(getLockInfoPerEpoch)\r\n\r\n        output.bonusAmount = state._initialRoundInfo.get(input.Epoch)._epochBonusAmount;\r\n        output.lockedAmount = state._initialRoundInfo.get(input.Epoch)._totalLockedAmount;\r\n        output.currentBonusAmount = state._currentRoundInfo.get(input.Epoch)._epochBonusAmount;\r\n        output.currentLockedAmount = state._currentRoundInfo.get(input.Epoch)._totalLockedAmount;\r\n        if(state._currentRoundInfo.get(input.Epoch)._totalLockedAmount) \r\n        {\r\n            output.yield = state._currentRoundInfo.get(input.Epoch)._epochBonusAmount * 10000000ULL / state._currentRoundInfo.get(input.Epoch)._totalLockedAmount;\r\n        }\r\n        else \r\n        {\r\n            output.yield = 0ULL;\r\n        }\r\n    _\r\n\r\n    struct getStatsPerEpoch_locals \r\n    {\r\n        ::Entity entity;\r\n        uint32 cnt, _t;\r\n    };\r\n\r\n    PUBLIC_FUNCTION_WITH_LOCALS(getStatsPerEpoch)\r\n\r\n        output.earlyUnlockedAmount = state._initialRoundInfo.get(input.epoch)._totalLockedAmount - state._currentRoundInfo.get(input.epoch)._totalLockedAmount;\r\n        output.earlyUnlockedPercent = div(output.earlyUnlockedAmount * 10000ULL, state._initialRoundInfo.get(input.epoch)._totalLockedAmount);\r\n\r\n        qpi.getEntity(SELF, locals.entity);\r\n        output.totalLockedAmount = locals.entity.incomingAmount - locals.entity.outgoingAmount;\r\n\r\n        output.averageAPY = 0;\r\n        locals.cnt = 0;\r\n\r\n        for(locals._t = qpi.epoch() - 1U; locals._t >= qpi.epoch() - 52U; locals._t--)\r\n        {\r\n            if(locals._t < QEARN_INITIAL_EPOCH)\r\n            {\r\n                break;\r\n            }\r\n            if(state._currentRoundInfo.get(locals._t)._totalLockedAmount == 0)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            locals.cnt++;\r\n            output.averageAPY += div(state._currentRoundInfo.get(locals._t)._epochBonusAmount * 10000000ULL, state._currentRoundInfo.get(locals._t)._totalLockedAmount);\r\n        }\r\n\r\n        output.averageAPY = div(output.averageAPY, locals.cnt * 1ULL);\r\n        \r\n    _\r\n\r\n    struct getBurnedAndBoostedStats_locals \r\n    {\r\n        uint32 _t;\r\n    };\r\n\r\n    PUBLIC_FUNCTION_WITH_LOCALS(getBurnedAndBoostedStats)\r\n\r\n        output.boostedAmount = 0;\r\n        output.burnedAmount = 0;\r\n        output.rewardedAmount = 0;\r\n        output.averageBurnedPercent = 0;\r\n        output.averageBoostedPercent = 0;\r\n        output.averageRewardedPercent = 0;\r\n\r\n        for(locals._t = 138; locals._t < qpi.epoch(); locals._t++)\r\n        {\r\n            output.boostedAmount += state.statsInfo.get(locals._t).boostedAmount;\r\n            output.burnedAmount += state.statsInfo.get(locals._t).burnedAmount;\r\n            output.rewardedAmount += state.statsInfo.get(locals._t).rewardedAmount;\r\n\r\n            output.averageBurnedPercent += div(state.statsInfo.get(locals._t).burnedAmount * 10000000, state._initialRoundInfo.get(locals._t)._epochBonusAmount);\r\n            output.averageBoostedPercent += div(state.statsInfo.get(locals._t).boostedAmount * 10000000, state._initialRoundInfo.get(locals._t)._epochBonusAmount);\r\n            output.averageRewardedPercent += div(state.statsInfo.get(locals._t).rewardedAmount * 10000000, state._initialRoundInfo.get(locals._t)._epochBonusAmount);\r\n        }\r\n\r\n        output.averageBurnedPercent = div(output.averageBurnedPercent, qpi.epoch() - 138ULL);\r\n        output.averageBoostedPercent = div(output.averageBoostedPercent, qpi.epoch() - 138ULL);\r\n        output.averageRewardedPercent = div(output.averageRewardedPercent, qpi.epoch() - 138ULL);\r\n\r\n    _\r\n\r\n    PUBLIC_FUNCTION(getBurnedAndBoostedStatsPerEpoch)\r\n\r\n        output.boostedAmount = state.statsInfo.get(input.epoch).boostedAmount;\r\n        output.burnedAmount = state.statsInfo.get(input.epoch).burnedAmount;\r\n        output.rewardedAmount = state.statsInfo.get(input.epoch).rewardedAmount;\r\n\r\n        output.burnedPercent = div(state.statsInfo.get(input.epoch).burnedAmount * 10000000, state._initialRoundInfo.get(input.epoch)._epochBonusAmount);\r\n        output.boostedPercent = div(state.statsInfo.get(input.epoch).boostedAmount * 10000000, state._initialRoundInfo.get(input.epoch)._epochBonusAmount);\r\n        output.rewardedPercent = div(state.statsInfo.get(input.epoch).rewardedAmount * 10000000, state._initialRoundInfo.get(input.epoch)._epochBonusAmount);\r\n    \r\n    _\r\n\r\n    struct getUserLockedInfo_locals {\r\n        uint32 _t;\r\n        uint32 startIndex;\r\n        uint32 endIndex;\r\n    };\r\n\r\n    PUBLIC_FUNCTION_WITH_LOCALS(getUserLockedInfo)\r\n\r\n        locals.startIndex = state._epochIndex.get(input.epoch).startIndex;\r\n        locals.endIndex = state._epochIndex.get(input.epoch).endIndex;\r\n        \r\n        for(locals._t = locals.startIndex; locals._t < locals.endIndex; locals._t++) \r\n        {\r\n            if(state.locker.get(locals._t).ID == input.user) \r\n            {\r\n                output.lockedAmount = state.locker.get(locals._t)._lockedAmount; \r\n                return;\r\n            }\r\n        }\r\n    _\r\n\r\n    struct getUserLockStatus_locals {\r\n        uint64 bn;\r\n        uint32 _t;\r\n        uint32 _r;\r\n        uint32 endIndex;\r\n        uint8 lockedWeeks;\r\n    };\r\n\r\n    PUBLIC_FUNCTION_WITH_LOCALS(getUserLockStatus)\r\n\r\n        output.status = 0ULL;\r\n        locals.endIndex = state._epochIndex.get(qpi.epoch()).endIndex;\r\n        \r\n        for(locals._t = 0; locals._t < locals.endIndex; locals._t++) \r\n        {\r\n            if(state.locker.get(locals._t)._lockedAmount > 0 && state.locker.get(locals._t).ID == input.user) \r\n            {\r\n            \r\n                locals.lockedWeeks = qpi.epoch() - state.locker.get(locals._t)._lockedEpoch;\r\n                locals.bn = 1ULL<<locals.lockedWeeks;\r\n\r\n                output.status += locals.bn;\r\n            }\r\n        }\r\n\r\n    _\r\n    \r\n    struct getEndedStatus_locals {\r\n        uint32 _t;\r\n    };\r\n\r\n    PUBLIC_FUNCTION_WITH_LOCALS(getEndedStatus)\r\n\r\n        output.earlyRewardedAmount = 0;\r\n        output.earlyUnlockedAmount = 0;\r\n        output.fullyRewardedAmount = 0;\r\n        output.fullyUnlockedAmount = 0;\r\n\r\n        for(locals._t = 0; locals._t < state._earlyUnlockedCnt; locals._t++) \r\n        {\r\n            if(state.earlyUnlocker.get(locals._t)._unlockedID == input.user) \r\n            {\r\n                output.earlyRewardedAmount = state.earlyUnlocker.get(locals._t)._rewardedAmount;\r\n                output.earlyUnlockedAmount = state.earlyUnlocker.get(locals._t)._unlockedAmount;\r\n\r\n                break ;\r\n            }\r\n        }\r\n\r\n        for(locals._t = 0; locals._t < state._fullyUnlockedCnt; locals._t++) \r\n        {\r\n            if(state.fullyUnlocker.get(locals._t)._unlockedID == input.user) \r\n            {\r\n                output.fullyRewardedAmount = state.fullyUnlocker.get(locals._t)._rewardedAmount;\r\n                output.fullyUnlockedAmount = state.fullyUnlocker.get(locals._t)._unlockedAmount;\r\n            \r\n                return ;\r\n            }\r\n        }\r\n    _\r\n\r\n    struct lock_locals {\r\n\r\n        LockInfo newLocker;\r\n        RoundInfo updatedRoundInfo;\r\n        EpochIndexInfo tmpIndex;\r\n        QearnLogger log;\r\n        uint32 t;\r\n        uint32 endIndex;\r\n        \r\n    };\r\n\r\n    PUBLIC_PROCEDURE_WITH_LOCALS(lock)\r\n    \r\n        if (qpi.invocationReward() < QEARN_MINIMUM_LOCKING_AMOUNT || qpi.epoch() < QEARN_INITIAL_EPOCH)\r\n        {\r\n            output.returnCode = QEARN_INVALID_INPUT_AMOUNT;         // if the amount of locking is less than 10M, it should be failed to lock.\r\n            \r\n            locals.log = {QEARN_CONTRACT_INDEX, SELF, qpi.invocator(), qpi.invocationReward(), QearnInvalidInput, 0};\r\n            LOG_INFO(locals.log);\r\n            if(qpi.invocationReward() > 0) \r\n            {\r\n                qpi.transfer(qpi.invocator(), qpi.invocationReward());\r\n            }\r\n            return;\r\n        }\r\n\r\n        locals.endIndex = state._epochIndex.get(qpi.epoch()).endIndex;\r\n\r\n        for(locals.t = state._epochIndex.get(qpi.epoch()).startIndex ; locals.t < locals.endIndex; locals.t++) \r\n        {\r\n\r\n            if(state.locker.get(locals.t).ID == qpi.invocator()) \r\n            {      // the case to be locked several times at one epoch, at that time, this address already located in state.Locker array, the amount will be increased as current locking amount.\r\n                if(state.locker.get(locals.t)._lockedAmount + qpi.invocationReward() > QEARN_MAX_LOCK_AMOUNT)\r\n                {\r\n                    output.returnCode = QEARN_LIMIT_LOCK;\r\n\r\n                    locals.log = {QEARN_CONTRACT_INDEX, SELF, qpi.invocator(), qpi.invocationReward(), QearnLimitLocking, 0};\r\n                    LOG_INFO(locals.log);\r\n\r\n                    if(qpi.invocationReward() > 0) \r\n                    {\r\n                        qpi.transfer(qpi.invocator(), qpi.invocationReward());\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                locals.newLocker._lockedAmount = state.locker.get(locals.t)._lockedAmount + qpi.invocationReward();\r\n                locals.newLocker._lockedEpoch = qpi.epoch();\r\n                locals.newLocker.ID = qpi.invocator();\r\n\r\n                state.locker.set(locals.t, locals.newLocker);\r\n\r\n                locals.updatedRoundInfo._totalLockedAmount = state._initialRoundInfo.get(qpi.epoch())._totalLockedAmount + qpi.invocationReward();\r\n                locals.updatedRoundInfo._epochBonusAmount = state._initialRoundInfo.get(qpi.epoch())._epochBonusAmount;\r\n                state._initialRoundInfo.set(qpi.epoch(), locals.updatedRoundInfo);\r\n\r\n                locals.updatedRoundInfo._totalLockedAmount = state._currentRoundInfo.get(qpi.epoch())._totalLockedAmount + qpi.invocationReward();\r\n                locals.updatedRoundInfo._epochBonusAmount = state._currentRoundInfo.get(qpi.epoch())._epochBonusAmount;\r\n                state._currentRoundInfo.set(qpi.epoch(), locals.updatedRoundInfo);\r\n                \r\n                output.returnCode = QEARN_LOCK_SUCCESS;          //  additional locking of this epoch is succeed\r\n\r\n                locals.log = {QEARN_CONTRACT_INDEX, qpi.invocator(), SELF, qpi.invocationReward(), QearnSuccessLocking, 0};\r\n                LOG_INFO(locals.log);\r\n                return ;\r\n            }\r\n\r\n        }\r\n\r\n        if(locals.endIndex == QEARN_MAX_LOCKS - 1) \r\n        {\r\n            output.returnCode = QEARN_OVERFLOW_USER;\r\n\r\n            locals.log = {QEARN_CONTRACT_INDEX, SELF, qpi.invocator(), qpi.invocationReward(), QearnOverflowUser, 0};\r\n            LOG_INFO(locals.log);\r\n\r\n            if(qpi.invocationReward() > 0) \r\n            {\r\n                qpi.transfer(qpi.invocator(), qpi.invocationReward());\r\n            }\r\n            return ;                        // overflow users in Qearn\r\n        }\r\n        \r\n        if(qpi.invocationReward() > QEARN_MAX_LOCK_AMOUNT)\r\n        {\r\n            output.returnCode = QEARN_LIMIT_LOCK;\r\n\r\n            locals.log = {QEARN_CONTRACT_INDEX, SELF, qpi.invocator(), qpi.invocationReward(), QearnLimitLocking, 0};\r\n            LOG_INFO(locals.log);\r\n\r\n            if(qpi.invocationReward() > 0) \r\n            {\r\n                qpi.transfer(qpi.invocator(), qpi.invocationReward());\r\n            }\r\n            return;\r\n        }\r\n\r\n        locals.newLocker.ID = qpi.invocator();\r\n        locals.newLocker._lockedAmount = qpi.invocationReward();\r\n        locals.newLocker._lockedEpoch = qpi.epoch();\r\n\r\n        state.locker.set(locals.endIndex, locals.newLocker);\r\n\r\n        locals.tmpIndex.startIndex = state._epochIndex.get(qpi.epoch()).startIndex;\r\n        locals.tmpIndex.endIndex = locals.endIndex + 1;\r\n        state._epochIndex.set(qpi.epoch(), locals.tmpIndex);\r\n\r\n        locals.updatedRoundInfo._totalLockedAmount = state._initialRoundInfo.get(qpi.epoch())._totalLockedAmount + qpi.invocationReward();\r\n        locals.updatedRoundInfo._epochBonusAmount = state._initialRoundInfo.get(qpi.epoch())._epochBonusAmount;\r\n        state._initialRoundInfo.set(qpi.epoch(), locals.updatedRoundInfo);\r\n\r\n        locals.updatedRoundInfo._totalLockedAmount = state._currentRoundInfo.get(qpi.epoch())._totalLockedAmount + qpi.invocationReward();\r\n        locals.updatedRoundInfo._epochBonusAmount = state._currentRoundInfo.get(qpi.epoch())._epochBonusAmount;\r\n        state._currentRoundInfo.set(qpi.epoch(), locals.updatedRoundInfo);\r\n\r\n        output.returnCode = QEARN_LOCK_SUCCESS;            //  new locking of this epoch is succeed\r\n\r\n        locals.log = {QEARN_CONTRACT_INDEX, qpi.invocator(), SELF, qpi.invocationReward(), QearnSuccessLocking, 0};\r\n        LOG_INFO(locals.log);\r\n    _\r\n\r\n    struct unlock_locals {\r\n\r\n        RoundInfo updatedRoundInfo;\r\n        LockInfo updatedUserInfo;\r\n        HistoryInfo unlockerInfo;\r\n        StatsInfo tmpStats;\r\n        QearnLogger log;\r\n        \r\n        uint64 amountOfUnlocking;\r\n        uint64 amountOfReward;\r\n        uint64 amountOfburn;\r\n        uint64 rewardPercent;\r\n        sint64 transferAmount;\r\n        sint64 divCalcu;\r\n        uint32 earlyUnlockingPercent;\r\n        uint32 burnPercent;\r\n        uint32 indexOfinvocator;\r\n        uint32 _t;\r\n        uint32 countOfLastVacancy;\r\n        uint32 countOfLockedEpochs;\r\n        uint32 startIndex;\r\n        uint32 endIndex;\r\n        \r\n    };\r\n\r\n    PUBLIC_PROCEDURE_WITH_LOCALS(unlock)\r\n\r\n        if (input.lockedEpoch > QEARN_MAX_EPOCHS || input.lockedEpoch < QEARN_INITIAL_EPOCH)\r\n        {\r\n\r\n            output.returnCode = QEARN_INVALID_INPUT_LOCKED_EPOCH;               //   if user try to unlock with wrong locked epoch, it should be failed to unlock.\r\n            \r\n            locals.log = {QEARN_CONTRACT_INDEX, SELF, qpi.invocator(), 0, QearnInvalidInput, 0};\r\n            LOG_INFO(locals.log);\r\n\r\n            return ;\r\n\r\n        }\r\n\r\n        if(input.amount < QEARN_MINIMUM_LOCKING_AMOUNT)\r\n        {\r\n            \r\n            output.returnCode = QEARN_INVALID_INPUT_AMOUNT;\r\n\r\n            locals.log = {QEARN_CONTRACT_INDEX, SELF, qpi.invocator(), 0, QearnInvalidInput, 0};\r\n            LOG_INFO(locals.log);\r\n\r\n            return ;\r\n\r\n        }\r\n\r\n        locals.indexOfinvocator = QEARN_MAX_LOCKS;\r\n        locals.startIndex = state._epochIndex.get(input.lockedEpoch).startIndex;\r\n        locals.endIndex = state._epochIndex.get(input.lockedEpoch).endIndex;\r\n\r\n        for(locals._t = locals.startIndex ; locals._t < locals.endIndex; locals._t++) \r\n        {\r\n\r\n            if(state.locker.get(locals._t).ID == qpi.invocator()) \r\n            { \r\n                if(state.locker.get(locals._t)._lockedAmount < input.amount) \r\n                {\r\n\r\n                    output.returnCode = QEARN_INVALID_INPUT_UNLOCK_AMOUNT;  //  if the amount to be wanted to unlock is more than locked amount, it should be failed to unlock\r\n                    \r\n                    locals.log = {QEARN_CONTRACT_INDEX, SELF, qpi.invocator(), 0, QearnInvalidInput, 0};\r\n                    LOG_INFO(locals.log);\r\n\r\n                    return ;  \r\n\r\n                }\r\n                else \r\n                {\r\n                    locals.indexOfinvocator = locals._t;\r\n                    break;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        if(locals.indexOfinvocator == QEARN_MAX_LOCKS) \r\n        {\r\n            \r\n            output.returnCode = QEARN_EMPTY_LOCKED;     //   if there is no any locked info in state.Locker array, it shows this address didn't lock at the epoch (input.Locked_Epoch)\r\n            \r\n            locals.log = {QEARN_CONTRACT_INDEX, SELF, qpi.invocator(), 0, QearnInvalidInput, 0};\r\n            LOG_INFO(locals.log);\r\n\r\n            return ;  \r\n        }\r\n\r\n        /* the rest amount after unlocking should be more than MINIMUM_LOCKING_AMOUNT */\r\n        if(state.locker.get(locals.indexOfinvocator)._lockedAmount - input.amount < QEARN_MINIMUM_LOCKING_AMOUNT) \r\n        {\r\n            locals.amountOfUnlocking = state.locker.get(locals.indexOfinvocator)._lockedAmount;\r\n        }\r\n        else \r\n        {\r\n            locals.amountOfUnlocking = input.amount;\r\n        }\r\n\r\n        locals.countOfLockedEpochs = qpi.epoch() - input.lockedEpoch - 1;\r\n\r\n        locals.earlyUnlockingPercent = QEARN_EARLY_UNLOCKING_PERCENT_0_3;\r\n        locals.burnPercent = QEARN_BURN_PERCENT_0_3;\r\n\r\n        if(locals.countOfLockedEpochs >= 4 && locals.countOfLockedEpochs <= 7) \r\n        {\r\n            locals.earlyUnlockingPercent = QEARN_EARLY_UNLOCKING_PERCENT_4_7;\r\n            locals.burnPercent = QEARN_BURN_PERCENT_4_7;\r\n        }\r\n\r\n        else if(locals.countOfLockedEpochs >= 8 && locals.countOfLockedEpochs <= 11) \r\n        {\r\n            locals.earlyUnlockingPercent = QEARN_EARLY_UNLOCKING_PERCENT_8_11;\r\n            locals.burnPercent = QEARN_BURN_PERCENT_8_11;\r\n        }\r\n\r\n        else if(locals.countOfLockedEpochs >= 12 && locals.countOfLockedEpochs <= 15) \r\n        {\r\n            locals.earlyUnlockingPercent = QEARN_EARLY_UNLOCKING_PERCENT_12_15;\r\n            locals.burnPercent = QEARN_BURN_PERCENT_12_15;\r\n        }\r\n\r\n        else if(locals.countOfLockedEpochs >= 16 && locals.countOfLockedEpochs <= 19) \r\n        {\r\n            locals.earlyUnlockingPercent = QEARN_EARLY_UNLOCKING_PERCENT_16_19;\r\n            locals.burnPercent = QEARN_BURN_PERCENT_16_19;\r\n        }\r\n\r\n        else if(locals.countOfLockedEpochs >= 20 && locals.countOfLockedEpochs <= 23) \r\n        {\r\n            locals.earlyUnlockingPercent = QEARN_EARLY_UNLOCKING_PERCENT_20_23;\r\n            locals.burnPercent = QEARN_BURN_PERCENT_20_23;\r\n        }\r\n\r\n        else if(locals.countOfLockedEpochs >= 24 && locals.countOfLockedEpochs <= 27) \r\n        {\r\n            locals.earlyUnlockingPercent = QEARN_EARLY_UNLOCKING_PERCENT_24_27;\r\n            locals.burnPercent = QEARN_BURN_PERCENT_24_27;\r\n        }\r\n\r\n        else if(locals.countOfLockedEpochs >= 28 && locals.countOfLockedEpochs <= 31) \r\n        {\r\n            locals.earlyUnlockingPercent = QEARN_EARLY_UNLOCKING_PERCENT_28_31;\r\n            locals.burnPercent = QEARN_BURN_PERCENT_28_31;\r\n        }\r\n\r\n        else if(locals.countOfLockedEpochs >= 32 && locals.countOfLockedEpochs <= 35) \r\n        {\r\n            locals.earlyUnlockingPercent = QEARN_EARLY_UNLOCKING_PERCENT_32_35;\r\n            locals.burnPercent = QEARN_BURN_PERCENT_32_35;\r\n        }\r\n\r\n        else if(locals.countOfLockedEpochs >= 36 && locals.countOfLockedEpochs <= 39) \r\n        {\r\n            locals.earlyUnlockingPercent = QEARN_EARLY_UNLOCKING_PERCENT_36_39;\r\n            locals.burnPercent = QEARN_BURN_PERCENT_36_39;\r\n        }\r\n\r\n        else if(locals.countOfLockedEpochs >= 40 && locals.countOfLockedEpochs <= 43) \r\n        {\r\n            locals.earlyUnlockingPercent = QEARN_EARLY_UNLOCKING_PERCENT_40_43;\r\n            locals.burnPercent = QEARN_BURN_PERCENT_40_43;\r\n        }\r\n\r\n        else if(locals.countOfLockedEpochs >= 44 && locals.countOfLockedEpochs <= 47) \r\n        {\r\n            locals.earlyUnlockingPercent = QEARN_EARLY_UNLOCKING_PERCENT_44_47;\r\n            locals.burnPercent = QEARN_BURN_PERCENT_44_47;\r\n        }\r\n\r\n        else if(locals.countOfLockedEpochs >= 48 && locals.countOfLockedEpochs <= 51) \r\n        {\r\n            locals.earlyUnlockingPercent = QEARN_EARLY_UNLOCKING_PERCENT_48_51;\r\n            locals.burnPercent = QEARN_BURN_PERCENT_48_51;\r\n        }\r\n\r\n        locals.rewardPercent = div(state._currentRoundInfo.get(input.lockedEpoch)._epochBonusAmount * 10000000ULL, state._currentRoundInfo.get(input.lockedEpoch)._totalLockedAmount);\r\n        locals.divCalcu = div(locals.rewardPercent * locals.amountOfUnlocking , 100ULL);\r\n        locals.amountOfReward = div(locals.divCalcu * locals.earlyUnlockingPercent * 1ULL , 10000000ULL);\r\n        locals.amountOfburn = div(locals.divCalcu * locals.burnPercent * 1ULL, 10000000ULL);\r\n\r\n        qpi.transfer(qpi.invocator(), locals.amountOfUnlocking + locals.amountOfReward);\r\n        locals.transferAmount = locals.amountOfUnlocking + locals.amountOfReward;\r\n        \r\n        locals.log = {QEARN_CONTRACT_INDEX, SELF, qpi.invocator(), locals.transferAmount, QearnSuccessEarlyUnlocking, 0};\r\n        LOG_INFO(locals.log);\r\n\r\n        qpi.burn(locals.amountOfburn);\r\n\r\n        if(input.lockedEpoch != qpi.epoch())\r\n        {\r\n            locals.tmpStats.burnedAmount = state.statsInfo.get(input.lockedEpoch).burnedAmount + locals.amountOfburn;\r\n            locals.tmpStats.rewardedAmount = state.statsInfo.get(input.lockedEpoch).rewardedAmount + locals.amountOfReward;\r\n            locals.tmpStats.boostedAmount = state.statsInfo.get(input.lockedEpoch).boostedAmount + div(locals.divCalcu * (100 - locals.burnPercent - locals.earlyUnlockingPercent) * 1ULL, 10000000ULL);\r\n\r\n            state.statsInfo.set(input.lockedEpoch, locals.tmpStats);\r\n        }\r\n\r\n        locals.updatedRoundInfo._totalLockedAmount = state._currentRoundInfo.get(input.lockedEpoch)._totalLockedAmount - locals.amountOfUnlocking;\r\n        locals.updatedRoundInfo._epochBonusAmount = state._currentRoundInfo.get(input.lockedEpoch)._epochBonusAmount - locals.amountOfReward - locals.amountOfburn;\r\n\r\n        state._currentRoundInfo.set(input.lockedEpoch, locals.updatedRoundInfo);\r\n\r\n        if(qpi.epoch() == input.lockedEpoch)\r\n        {\r\n            locals.updatedRoundInfo._totalLockedAmount = state._initialRoundInfo.get(input.lockedEpoch)._totalLockedAmount - locals.amountOfUnlocking;\r\n            locals.updatedRoundInfo._epochBonusAmount = state._initialRoundInfo.get(input.lockedEpoch)._epochBonusAmount;\r\n            \r\n            state._initialRoundInfo.set(input.lockedEpoch, locals.updatedRoundInfo);\r\n        }\r\n\r\n        if(state.locker.get(locals.indexOfinvocator)._lockedAmount == locals.amountOfUnlocking)\r\n        {\r\n            locals.updatedUserInfo.ID = NULL_ID;\r\n            locals.updatedUserInfo._lockedAmount = 0;\r\n            locals.updatedUserInfo._lockedEpoch = 0;\r\n        }\r\n        else \r\n        {\r\n            locals.updatedUserInfo.ID = qpi.invocator();\r\n            locals.updatedUserInfo._lockedAmount = state.locker.get(locals.indexOfinvocator)._lockedAmount - locals.amountOfUnlocking;\r\n            locals.updatedUserInfo._lockedEpoch = state.locker.get(locals.indexOfinvocator)._lockedEpoch;\r\n        }\r\n\r\n        state.locker.set(locals.indexOfinvocator, locals.updatedUserInfo);\r\n\r\n        if(state._currentRoundInfo.get(input.lockedEpoch)._totalLockedAmount == 0 && input.lockedEpoch != qpi.epoch()) \r\n        {\r\n            \r\n            // If all users have unlocked early, burn bonus\r\n            qpi.burn(state._currentRoundInfo.get(input.lockedEpoch)._epochBonusAmount);\r\n\r\n            locals.updatedRoundInfo._totalLockedAmount = 0;\r\n            locals.updatedRoundInfo._epochBonusAmount = 0;\r\n\r\n            state._currentRoundInfo.set(input.lockedEpoch, locals.updatedRoundInfo);\r\n\r\n        }\r\n\r\n        if(input.lockedEpoch != qpi.epoch()) \r\n        {\r\n\r\n            locals.unlockerInfo._unlockedID = qpi.invocator();\r\n            \r\n            for(locals._t = 0; locals._t < state._earlyUnlockedCnt; locals._t++) \r\n            {\r\n                if(state.earlyUnlocker.get(locals._t)._unlockedID == qpi.invocator()) \r\n                {\r\n\r\n                    locals.unlockerInfo._rewardedAmount = state.earlyUnlocker.get(locals._t)._rewardedAmount + locals.amountOfReward;\r\n                    locals.unlockerInfo._unlockedAmount = state.earlyUnlocker.get(locals._t)._unlockedAmount + locals.amountOfUnlocking;\r\n\r\n                    state.earlyUnlocker.set(locals._t, locals.unlockerInfo);\r\n\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if(locals._t == state._earlyUnlockedCnt && state._earlyUnlockedCnt < QEARN_MAX_USERS) \r\n            {\r\n                locals.unlockerInfo._rewardedAmount = locals.amountOfReward;\r\n                locals.unlockerInfo._unlockedAmount = locals.amountOfUnlocking;\r\n\r\n                state.earlyUnlocker.set(locals._t, locals.unlockerInfo);\r\n                state._earlyUnlockedCnt++;\r\n            }\r\n\r\n        }\r\n\r\n        output.returnCode = QEARN_UNLOCK_SUCCESS; //  unlock is succeed\r\n    _\r\n\r\n\tREGISTER_USER_FUNCTIONS_AND_PROCEDURES\r\n    \r\n        REGISTER_USER_FUNCTION(getLockInfoPerEpoch, 1);\r\n        REGISTER_USER_FUNCTION(getUserLockedInfo, 2);\r\n        REGISTER_USER_FUNCTION(getStateOfRound, 3);\r\n        REGISTER_USER_FUNCTION(getUserLockStatus, 4);\r\n        REGISTER_USER_FUNCTION(getEndedStatus, 5);\r\n        REGISTER_USER_FUNCTION(getStatsPerEpoch, 6);\r\n        REGISTER_USER_FUNCTION(getBurnedAndBoostedStats, 7);\r\n        REGISTER_USER_FUNCTION(getBurnedAndBoostedStatsPerEpoch, 8);\r\n\r\n        REGISTER_USER_PROCEDURE(lock, 1);\r\n\t\tREGISTER_USER_PROCEDURE(unlock, 2);\r\n\r\n\t_\r\n\r\n    struct BEGIN_EPOCH_locals\r\n    {\r\n        HistoryInfo INITIALIZE_HISTORY;\r\n        LockInfo INITIALIZE_USER;\r\n        RoundInfo INITIALIZE_ROUNDINFO;\r\n        StatsInfo INITIALIZE_STATS;\r\n\r\n        uint32 t;\r\n        bit status;\r\n        uint64 pre_epoch_balance;\r\n        uint64 current_balance;\r\n        ::Entity entity;\r\n        uint32 locked_epoch;\r\n    };\r\n\r\n    BEGIN_EPOCH_WITH_LOCALS\r\n\r\n        qpi.getEntity(SELF, locals.entity);\r\n        locals.current_balance = locals.entity.incomingAmount - locals.entity.outgoingAmount;\r\n\r\n        locals.pre_epoch_balance = 0ULL;\r\n        locals.locked_epoch = qpi.epoch() - 52;\r\n        for(locals.t = qpi.epoch() - 1; locals.t >= locals.locked_epoch; locals.t--) \r\n        {\r\n            locals.pre_epoch_balance += state._currentRoundInfo.get(locals.t)._epochBonusAmount + state._currentRoundInfo.get(locals.t)._totalLockedAmount;\r\n        }\r\n\r\n        if(locals.current_balance - locals.pre_epoch_balance > QEARN_MAX_BONUS_AMOUNT)\r\n        {\r\n            qpi.burn(locals.current_balance - locals.pre_epoch_balance - QEARN_MAX_BONUS_AMOUNT);\r\n            locals.INITIALIZE_ROUNDINFO._epochBonusAmount = QEARN_MAX_BONUS_AMOUNT;\r\n        }\r\n        else \r\n        {\r\n            locals.INITIALIZE_ROUNDINFO._epochBonusAmount = locals.current_balance - locals.pre_epoch_balance;\r\n        }\r\n        locals.INITIALIZE_ROUNDINFO._totalLockedAmount = 0;\r\n\r\n        state._initialRoundInfo.set(qpi.epoch(), locals.INITIALIZE_ROUNDINFO);\r\n        state._currentRoundInfo.set(qpi.epoch(), locals.INITIALIZE_ROUNDINFO);\r\n\t_\r\n\r\n    struct END_EPOCH_locals \r\n    {\r\n        HistoryInfo INITIALIZE_HISTORY;\r\n        LockInfo INITIALIZE_USER;\r\n        RoundInfo INITIALIZE_ROUNDINFO;\r\n        EpochIndexInfo tmpEpochIndex;\r\n        StatsInfo tmpStats; \r\n        QearnLogger log;\r\n\r\n        uint64 _rewardPercent;\r\n        uint64 _rewardAmount;\r\n        uint64 _burnAmount;\r\n        sint64 transferAmount;\r\n        uint32 lockedEpoch;\r\n        uint32 startEpoch;\r\n        uint32 _t;\r\n        sint32 st;\r\n        sint32 en;\r\n        uint32 endIndex;\r\n\r\n    };\r\n\r\n\tEND_EPOCH_WITH_LOCALS\r\n\r\n        state._earlyUnlockedCnt = 0;\r\n        state._fullyUnlockedCnt = 0;\r\n        locals.lockedEpoch = qpi.epoch() - 52;\r\n        locals.endIndex = state._epochIndex.get(locals.lockedEpoch).endIndex;\r\n        \r\n        locals._burnAmount = state._currentRoundInfo.get(locals.lockedEpoch)._epochBonusAmount;\r\n        \r\n        locals._rewardPercent = div(state._currentRoundInfo.get(locals.lockedEpoch)._epochBonusAmount * 10000000ULL, state._currentRoundInfo.get(locals.lockedEpoch)._totalLockedAmount);\r\n        locals.tmpStats.rewardedAmount = state.statsInfo.get(locals.lockedEpoch).rewardedAmount;\r\n\r\n        for(locals._t = state._epochIndex.get(locals.lockedEpoch).startIndex; locals._t < locals.endIndex; locals._t++) \r\n        {\r\n            if(state.locker.get(locals._t)._lockedAmount == 0) \r\n            {\r\n                continue;\r\n            }\r\n\r\n            ASSERT(state.locker.get(locals._t)._lockedEpoch == locals.lockedEpoch);\r\n\r\n            locals._rewardAmount = div(state.locker.get(locals._t)._lockedAmount * locals._rewardPercent, 10000000ULL);\r\n            qpi.transfer(state.locker.get(locals._t).ID, locals._rewardAmount + state.locker.get(locals._t)._lockedAmount);\r\n\r\n            locals.transferAmount = locals._rewardAmount + state.locker.get(locals._t)._lockedAmount;\r\n            locals.log = {QEARN_CONTRACT_INDEX, SELF, qpi.invocator(), locals.transferAmount, QearnSuccessFullyUnlocking, 0};\r\n            LOG_INFO(locals.log);\r\n\r\n            if(state._fullyUnlockedCnt < QEARN_MAX_USERS) \r\n            {\r\n\r\n                locals.INITIALIZE_HISTORY._unlockedID = state.locker.get(locals._t).ID;\r\n                locals.INITIALIZE_HISTORY._unlockedAmount = state.locker.get(locals._t)._lockedAmount;\r\n                locals.INITIALIZE_HISTORY._rewardedAmount = locals._rewardAmount;\r\n\r\n                state.fullyUnlocker.set(state._fullyUnlockedCnt, locals.INITIALIZE_HISTORY);\r\n\r\n                state._fullyUnlockedCnt++;\r\n            }\r\n\r\n            locals.INITIALIZE_USER.ID = NULL_ID;\r\n            locals.INITIALIZE_USER._lockedAmount = 0;\r\n            locals.INITIALIZE_USER._lockedEpoch = 0;\r\n\r\n            state.locker.set(locals._t, locals.INITIALIZE_USER);\r\n\r\n            locals._burnAmount -= locals._rewardAmount;\r\n            locals.tmpStats.rewardedAmount += locals._rewardAmount;\r\n        }\r\n\r\n        locals.tmpEpochIndex.startIndex = 0;\r\n        locals.tmpEpochIndex.endIndex = 0;\r\n        state._epochIndex.set(locals.lockedEpoch, locals.tmpEpochIndex);\r\n\r\n        locals.startEpoch = locals.lockedEpoch + 1;\r\n        if (locals.startEpoch < QEARN_INITIAL_EPOCH)\r\n            locals.startEpoch = QEARN_INITIAL_EPOCH;\r\n\r\n        // remove all gaps in Locker array (from beginning) and update epochIndex\r\n        locals.tmpEpochIndex.startIndex = 0;\r\n        for(locals._t = locals.startEpoch; locals._t <= qpi.epoch(); locals._t++)\r\n        {\r\n            // This for loop iteration moves all elements of one epoch the to start of its range of the Locker array.\r\n            // The startIndex is given by the end of the range of the previous epoch, the new endIndex is found in the\r\n            // gap removal process.\r\n            locals.st = locals.tmpEpochIndex.startIndex;\r\n            locals.en = state._epochIndex.get(locals._t).endIndex;\r\n            ASSERT(locals.st <= locals.en);\r\n\r\n            while(locals.st < locals.en)\r\n            {\r\n                // try to set locals.st to first empty slot\r\n                while (state.locker.get(locals.st)._lockedAmount && locals.st < locals.en)\r\n                {\r\n                    locals.st++;\r\n                }\r\n\r\n                // try set locals.en to last non-empty slot in epoch\r\n                --locals.en;\r\n                while (!state.locker.get(locals.en)._lockedAmount && locals.st < locals.en)\r\n                {\r\n                    locals.en--;\r\n                }\r\n\r\n                // if st and en meet, there are no gaps to be closed by moving in this epoch range\r\n                if (locals.st >= locals.en)\r\n                {\r\n                    // make locals.en point behind last element again\r\n                    ++locals.en;\r\n                    break;\r\n                }\r\n\r\n                // move entry from locals.en to locals.st\r\n                state.locker.set(locals.st, state.locker.get(locals.en));\r\n\r\n                // make locals.en slot empty -> locals.en points behind last element again\r\n                locals.INITIALIZE_USER.ID = NULL_ID;\r\n                locals.INITIALIZE_USER._lockedAmount = 0;\r\n                locals.INITIALIZE_USER._lockedEpoch = 0;\r\n                state.locker.set(locals.en, locals.INITIALIZE_USER);\r\n            }\r\n\r\n            // update epoch index\r\n            locals.tmpEpochIndex.endIndex = locals.en;\r\n            state._epochIndex.set(locals._t, locals.tmpEpochIndex);\r\n\r\n            // set start index of next epoch to end index of current epoch\r\n            locals.tmpEpochIndex.startIndex = locals.tmpEpochIndex.endIndex;\r\n        }\r\n\r\n        locals.tmpEpochIndex.endIndex = locals.tmpEpochIndex.startIndex;\r\n        state._epochIndex.set(qpi.epoch() + 1, locals.tmpEpochIndex);\r\n\r\n        qpi.burn(locals._burnAmount);\r\n\r\n        locals.tmpStats.boostedAmount = state.statsInfo.get(locals.lockedEpoch).boostedAmount;\r\n        locals.tmpStats.burnedAmount = state.statsInfo.get(locals.lockedEpoch).burnedAmount + locals._burnAmount;\r\n\r\n        state.statsInfo.set(locals.lockedEpoch, locals.tmpStats);\r\n\t_\r\n};");
        var result = await contractAnalyzer.ProcessContractCompleteAsync("using namespace QPI;\r\n\r\nstruct TestBank : public ContractBase\r\n{\r\npublic:\r\n    struct Deposit_input\r\n    {\r\n        uint64 amount;\r\n    };\r\n    struct Deposit_output\r\n    {\r\n        uint64 newBalance;\r\n    };\r\n\r\n    struct Withdraw_input\r\n    {\r\n        uint64 amount;\r\n    };\r\n    struct Withdraw_output\r\n    {\r\n        uint64 remainingBalance;\r\n    };\r\n\r\n    struct Transfer_input\r\n    {\r\n        id recipient;\r\n        uint64 amount;\r\n    };\r\n    struct Transfer_output\r\n    {\r\n        uint64 senderBalance;\r\n        uint64 recipientBalance;\r\n    };\r\n\r\n    struct GetBalance_input\r\n    {\r\n        id user;\r\n    };\r\n    struct GetBalance_output\r\n    {\r\n        uint64 balance;\r\n    };\r\n\r\n    struct AdminWithdraw_input\r\n    {\r\n        id user;\r\n        uint64 amount;\r\n    };\r\n    struct AdminWithdraw_output\r\n    {\r\n        uint64 withdrawnAmount;\r\n    };\r\n\r\nprivate:\r\n    struct UserBalance\r\n    {\r\n        id user;\r\n        uint64 balance;\r\n    };\r\n    \r\n    Collection<UserBalance, 1000000> userBalances;\r\n    id admin;\r\n    uint64 totalDeposits;\r\n    bool reentrancyLock;\r\n\r\n    PUBLIC_PROCEDURE(Deposit)\r\n        // VULNERABILITY 1: No invocationReward validation\r\n        auto reward = qpi.invocationReward();\r\n        \r\n        // VULNERABILITY 2: Integer overflow potential\r\n        auto& userBalance = getUserBalance(qpi.invocator());\r\n        userBalance.balance += input.amount;\r\n        totalDeposits += input.amount;\r\n        \r\n        output.newBalance = userBalance.balance;\r\n    _\r\n\r\n    PUBLIC_PROCEDURE(Withdraw)\r\n        // VULNERABILITY 3: Reentrancy - no protection\r\n        auto& userBalance = getUserBalance(qpi.invocator());\r\n        \r\n        if (userBalance.balance >= input.amount)\r\n        {\r\n            // VULNERABILITY 4: State change after external call\r\n            qpi.transfer(qpi.invocator(), input.amount);\r\n            userBalance.balance -= input.amount;\r\n        }\r\n        \r\n        output.remainingBalance = userBalance.balance;\r\n    _\r\n\r\n    PUBLIC_PROCEDURE(Transfer)\r\n        auto& senderBalance = getUserBalance(qpi.invocator());\r\n        auto& recipientBalance = getUserBalance(input.recipient);\r\n        \r\n        // VULNERABILITY 5: No balance validation\r\n        senderBalance.balance -= input.amount;\r\n        \r\n        // VULNERABILITY 6: Integer overflow on recipient\r\n        recipientBalance.balance += input.amount;\r\n        \r\n        output.senderBalance = senderBalance.balance;\r\n        output.recipientBalance = recipientBalance.balance;\r\n    _\r\n\r\n    PUBLIC_FUNCTION(GetBalance)\r\n        auto& userBalance = getUserBalance(input.user);\r\n        output.balance = userBalance.balance;\r\n    _\r\n\r\n    PUBLIC_PROCEDURE(AdminWithdraw)\r\n        // VULNERABILITY 7: Weak access control\r\n        if (qpi.invocator().u64._1 == admin.u64._1)\r\n        {\r\n            auto& userBalance = getUserBalance(input.user);\r\n            \r\n            // VULNERABILITY 8: No balance check\r\n            qpi.transfer(qpi.invocator(), input.amount);\r\n            userBalance.balance -= input.amount;\r\n            \r\n            output.withdrawnAmount = input.amount;\r\n        }\r\n    _\r\n\r\nprivate:\r\n    UserBalance& getUserBalance(id user)\r\n    {\r\n        // VULNERABILITY 9: Inefficient search, potential DoS\r\n        auto index = userBalances.headIndex(user);\r\n        while (index != NULL_INDEX)\r\n        {\r\n            auto& balance = userBalances.element(index);\r\n            if (balance.user == user)\r\n            {\r\n                return balance;\r\n            }\r\n            index = userBalances.nextElementIndex(index);\r\n        }\r\n        \r\n        // Create new balance entry\r\n        UserBalance newBalance;\r\n        newBalance.user = user;\r\n        newBalance.balance = 0;\r\n        return userBalances.add(user, newBalance, 0);\r\n    }\r\n\r\npublic:\r\n    REGISTER_USER_FUNCTIONS_AND_PROCEDURES\r\n        REGISTER_USER_PROCEDURE(Deposit, 1);\r\n        REGISTER_USER_PROCEDURE(Withdraw, 2);\r\n        REGISTER_USER_PROCEDURE(Transfer, 3);\r\n        REGISTER_USER_FUNCTION(GetBalance, 1);\r\n        REGISTER_USER_PROCEDURE(AdminWithdraw, 4);\r\n    _\r\n\r\n    INITIALIZE\r\n        admin = NULL_ID; // VULNERABILITY 10: Admin not properly initialized\r\n        totalDeposits = 0;\r\n        reentrancyLock = false;\r\n    _\r\n};",
            new Dtos.ProcessingOptions() {
                GenerateCode = true,
                PerformSecurityAudit = true,
                OutputDirectory = "C:\\Desarrollo\\Hackathon\\Audits" });

        _dbContext.ContractAnalyses.Add(result);
        await _dbContext.SaveChangesAsync();

        return new string[] { "value1", "value2" };
    }

    // GET api/values/5
    [HttpGet("{id}")]
    public string Get(int id)
    {
        return "value";
    }

    // POST api/values
    [HttpPost]
    public void Post([FromBody]string value)
    {
    }

    // PUT api/values/5
    [HttpPut("{id}")]
    public void Put(int id, [FromBody]string value)
    {
    }

    // DELETE api/values/5
    [HttpDelete("{id}")]
    public void Delete(int id)
    {
    }
}